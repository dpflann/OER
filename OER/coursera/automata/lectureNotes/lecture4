Nondeterministic Finite Automata

Nondeterminism
- a nondeterministic finite automato has the ability to be in several states a once
- transitions from a state on an input symbol can be to any set of states
- start in one start state
- accept if any sequence of choices leads to a final state
- intuitively: the NFA always "guess right"
- Example: Chessboard moves
  - move to red square
  - move to black square
  - start state - upper left corner
  - final state = lower right corner

Formal NFA
- a finite set of states, Q
- an input alphabet, Î£
- a transition function, Î´
- a start state in Q, q0
- a set of final states F subset Q

Transition Function of an NFA
- Î´(q, a) is a set of states
- Extend to strings as follows:
  - Basis: Î´(q, epsiolon) = { q }
  - Induction: Î´(q, wa) = the union over all states p in Î´(q, w) and Î´(p, a)

Language of an NFA
- a string w is accepted by an NFA if Î´(q0, w) contains at least one final state
- the language of the NFA is the set of strings it accepts

Equivalence of DFA's, NFA's
- a DFA can be turned into an NFA that accepts the same language
- If Î´_D(q, a) = p, let the NFA have Î´_N(q, a) = { p }
- Then the NFA is always in a set containing exactly one state - the state the DFA is in after reading
  the same input
- The NFA will look so much like the DFA
- For any NFA there is a DFA that accepts the same language
- proof is the subset construction
- the number of states of the DFA can be exponential in the number of states of the NFA
- NFA's accept exactly the regular languages

Subset Construction
- Given an NFA with states Q, inputs Î£, transition function Î´_N, start state q0, and final states F,
  construct the equivalent DFA with:
    - States 2^Q (set of all subsets of Q), powerset
    - Inputs Î£
    - Start state { q0 }
    - Final states = all those with a member in F
- Critical Point:
  - The DFA states have names that are sets of NFA states
  - But as a DFA state, an expression like { p, q } must be understood to be a single symbol, not as a set
- The transition function Î´_D is defined by:
  Î´_d( { q1, ..., qk }, a) is the union over all i = 1, ..., k of Î´_N(qi, a) * Remember critical point

Proof of Equivlance: Subset Construction
- Show by induction on |w| that:
  Î´_N(q0, w) = Î´_D({ q0 }, w)
  - Basis: w = ğ: Î´_N(q0, ğ) = Î´_D({ q0 }, ğ) = { q0 }
- Induction:
  - Assume IH for strings shorter than w
  - Let w = xa; IH holds fo x
  - Let Î´_N(qo, x) = Î´_D({ q0 }, x) = S
  - Let T = union over all states p in S of Î´_N(p, a)
  - Then Î´_N(q0, w) = Î´_D({ q0 }, w) = T

NFA's with ğ-Transitions (ğ-NFA)
- we can allow state-to-state transitions on ğ (empty) input
- there transitions are done spontaneously, without looking at the input string
- a convenience at times, but still only regular languages are accepted

Closure of States
- CL(q) = set of states you can reach from state q following only arcs labeled ğ
- closure of a set of states = union of the closure of each state
- can always reach q on ğ - that is CL(q) always contains q

Extended Delta
- Intution: Ë†Î´(q, w) is the set of states you can reach from q following a path labeled w
- Basis: Ë†Î´(q, ğ) = CL(q)
- Induction: Î´(q, xa) is computed by
  1. Start with Ë†Î´(q, x) = S
  2. Take the union of CL( Î´(q, a) ) for all p in S
- Language of an ğ-NFA is the set of strings w such that Î´(q0, w) contains a final state

Equivalence of NFA, ğ-NFA
- every NFA is an ğ-NFA
  - it just has no transitions on ğ
- Converse requires us to take an ğ-NFA and construct an NFA that accepts the same language
- We do so by combining ğ-transitions with the next transition on a real input
- Start with an ğ-NFA with states Q, inputs Î£, start state q0, final states F, and transition
  function Î´_E
- Construct an "ordinary" NFA with states Q, inputs Î£, start state q0, final states F', and transition
  function Î´_N
- Compute Î´_N(q, a) as follows:
  - 1. Let S = CL(q)
  - Î´_N(q, a) is the union over all p in S of Î´_E(p, q)
- F' = the set of states q such that CL(q) contains a state of F
- Prove by induction on |w| that
  CL( Î´_N(q0, w) ) = Ë†Î´_E(q0, w)
- Thus, the ğ-NFA accepts w if and only if the "ordinary" NFA does

Summary
- DFA's, NFA's, and ğ-NFA's all accept exactly the same set of languages: the regular languages
- The NFA types are easier to design and may have exponentially fewer states than a DFA
- Only a DFA can be implemented

